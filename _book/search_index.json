[["index.html", "My bookdown tutorial 1 はじめに", " My bookdown tutorial Masayuki Sakai 2021-10-15 1 はじめに bookdownを日本語で作ってみます "],["rの基本と数学的な基礎事項.html", "2 Rの基本と数学的な基礎事項", " 2 Rの基本と数学的な基礎事項 "],["数式の表現.html", "3 数式の表現 3.1 定理や証明", " 3 数式の表現 インラインでの記述ができます．\\(f(k) = {n \\choose k} p^k (1-p)^{n-k}\\) $f(k) = {n \\choose k} p^k (1-p)^{n-k}$ 数式ブロックを作る場合は$$で囲みます． \\[ f(k) = {n \\choose k} p^k (1-p)^{n-k} \\] 3.1 定理や証明 一般的な定理・証明などのフォーマットをbookdownでも実現できます．bookdownでは次のように記述します． ::: {.theorem name=&quot;Pythagorean theorem&quot;} 任意の直角三角形について$c$を最も長い辺として，その他の2つの辺を$a,b$とする． このとき $$a^2 + b^2 = c^2$$ が成り立つ． ::: 上記の結果は次のように表示されます． Theorem 3.1 (Pythagorean theorem) 任意の直角三角形について\\(c\\)を最も長い辺として，その他の2つの辺を\\(a,b\\)とする． このとき \\[a^2 + b^2 = c^2\\] が成り立つ． プリアンブルで設定したコマンドを使ってみる Example 3.1 (example test) テスト \\[\\mathbb N\\] 追加で定義したコマンドは使えるかな "],["まとめ.html", "4 まとめ", " 4 まとめ まとめを書く "],["確率の概念.html", "5 確率の概念 5.1 順列と組み合わせによる数え上げ 5.2 集合と確率", " 5 確率の概念 ここでは，確率を計算するにあたって必要な順列と組み合わせについて紹介していきます． 離散的な事象について，単純に確率を計算するには数え上げをする必要があります．すなわち， 考え得る全ての場合を重複が無いように数え上げなければ行けません．確率が「同様に確からしい」 とするならば，多くの場合確率は \\[ \\frac{1}{\\text{全ての場合の数}} \\] と定義されるでしょう． 5.1 順列と組み合わせによる数え上げ 5.1.1 順列：Permutation まず，\\(n!\\)という記号は階乗を表し\\(n! = n \\times (n-1) \\times (n-2) \\times \\cdots \\times 2 \\times 1\\)である．ただしここでは\\(n \\in \\mathbb N\\)とする． Definition 5.1 (順列) \\(n\\)個の相異なるものの順列を\\(n!\\)と定義する． さらに，応用として\\(n\\)人全員を並ばせるのではなく，\\(r(\\leq n)\\)人だけ並ばせることを考えます．これは順列の計算において\\(r\\)個掛けるだけということになるので \\[ n \\times (n-1) \\times (n-2) \\times \\cdots \\times (n - r +2) \\times (n - r + 1) \\] となります．これを\\(_nP_r\\)と書き，階乗を用いて表せば次のようになります． \\[ \\begin{equation} _n P_r = \\frac{n!}{(n-r)!} \\tag{5.1} \\end{equation} \\] つぎに，\\(n\\)個のうち同じものとみなせるケースを考えてみましょう．例えば，赤玉と青玉がそれぞれ\\(n_r\\)個，\\(n_b\\)個ずつあると考えます． このとき赤玉同士，青玉同士は区別しない並べ方は何通りあるでしょうか？このような場合は次の手順で考えていきます． まず先ほどの順列と同じように，全てを区別して何通りの並べ方があるか考える 本来区別せずに数えるべきものが何通りあったかを考える 1と2から求めたかった場合の数を計算する 1については赤玉と青玉の数の合計\\(n = n_r + n_b\\)個から，\\(n! = (n_r + n_b)!\\)となります．2について考えていきましょう．1では赤玉同士も全て区別して数え上げていますが，本来は区別したくありません． 考えてみると，赤玉と青玉それぞれの並べ方は\\(n_r!, n_b!\\)通りあることがわかります．そして，赤玉・青玉は1の考え方では\\(n_r!, n_b!\\)個ずつ重複して数え上げを行っていることがわかります．以上のことから3としては \\[ \\frac{n!}{n_r! n_b!} \\] とすれば，求めたい数になることがわかりました． 更にこれ一般化し，全体の中に\\(m\\)個種類のものが\\(n_1, \\ldots, n_m\\)個ずつあるとき，同じ種類のものを区別しないで並べる方法は\\(n=\\sum_{i=1}^{m} n_i\\)として \\[ \\begin{equation} \\frac{n!}{\\Pi_{i=1}^m n_i!} \\tag{5.2} \\end{equation} \\] となります． 通常の順列は，上記のケースにおいて\\(m\\)種類のものがそれぞれ1個ずつしかないという特別な場合と考えることもできます． 5.1.2 組み合わせ：Combination 次に\\(n\\)個のものから\\(r\\)個を選ぶことを考えます．このとき選び方は何通りあるでしょうか？まず，記号としてこれを\\(n \\choose r\\)や\\(_nCr\\)と表します．順列を応用して考えると，\\(_nPr\\)という操作は次のように分解できます． \\(n\\)個のものから\\(r\\)個を選ぶ（\\(={_n}C_r\\)） \\(r\\)個を全て並べる（\\(=r!\\)） すなわち \\[ _n P_r = {_n C_r} \\cdot r! \\] と書き下せます．あとはこの式を\\(_nC_r\\)について表し直せば \\[ \\begin{equation} _n C_r = \\frac{_nP_r}{r!} = \\frac{n!}{(n-r)!r!} \\tag{5.3} \\end{equation} \\] を得ることができました． 5.1.3 演習問題 次の問いに回答してください． Exercise 5.1 (順列と組み合わせの基本) 次の問いに回答してください． 6人を右から一列に並ぶときの並び方は何通りあるか． 6人から3人を一列に並ばせる．このとき並び方は何通りあるか． 6人から2人を選ぶ組み合わせは何通りあるか． 6人を2チームに分け，更に2つのチームを横に並べる方法は何通りあるか．この時チーム内の並び方は無視して良い． 丸いテーブルに6人が座る時，その並びは何通りあるか． Exercise 5.2 (誕生日問題) 25人の異なる人がいるとして，少なくとも同じ誕生日の人が二人はいるようなケースは何通りあるでしょうか．また，それと全ての25人の誕生日の組み合わせの場合の数との比を取って，同じ誕生日の人がいることが珍しいことかどうか確かめてみてください． 計算においては，2月29日は考慮しないものとし，誕生日は365日のいずれかであるものとします． 5.2 集合と確率 ここでは集合と確率について考えていきます．集合については「集合と論理」でその定義や基本的な性質を紹介しました．ですのでまずは確率について考えていきましょう．確率を集合に対して定義します．すなわち全体集合\\(\\Omega\\)の要素\\(e_i(i=1,2,\\ldots,k)\\)に対して，各要素\\(e_i\\)に対応する値\\(P(e_i)\\)が与えられていて，更に次を満たすとします． \\[ \\begin{equation} \\begin{aligned} &amp; 0 \\leq P(e_i) \\leq 1, \\hspace{5mm} i=1,2,\\ldots,k \\\\ &amp; \\sum_{i=1}^{k} P(e_i) = 1 \\end{aligned} \\tag{5.4} \\end{equation} \\] このとき，集合\\(A \\in \\Omega\\)のに対して，その確率\\(P(A)\\)を次のように定義します． \\[ \\begin{equation} P(A) = \\sum_{e_i \\in A} P(e_i) \\tag{5.5} \\end{equation} \\] ただし，空集合\\(\\emptyset\\)に対する確率は\\(0\\)とします．つまり\\(P(\\emptyset) = 0\\)です．以上より，任意の集合\\(A\\)に対して\\(0 \\leq P(A) \\leq 1\\)であり，\\(P(\\Omega) = 1\\)であることがわかります．以降は，確率が定義された集合を事象と呼びます． Exercise 5.3 面が\\(1 \\sim 6\\)まであるサイコロについて，全体集合\\(\\Omega = \\{1,2,3,4,5,6 \\}\\)として，(5.4)を満たすような\\(P(e_i)\\)をそれぞれ定めてください．ただし，全ての\\(e_i\\)に対して，\\(P(e_i) = 1/6\\)とする方法以外で考えてください． 5.2.1 集合の演算と確率 先ほど定義した確率と集合の関係から，集合演算の結果の確率についても自然に次式を得ることができます．集合\\(A,B \\in \\Omega\\)に対してその和事象\\(A \\cup B\\)の確率は \\[ \\begin{equation} \\begin{aligned} P(A \\cup B) &amp;= \\sum_{e_i \\in A \\cup B} P(e_i) \\\\ &amp;= \\sum_{e_i \\in A} P(e_i) + \\sum_{e_i \\in B} - \\sum_{e_i \\in A \\cap B} P(e_i) \\\\ &amp;= P(A) + P(B) - P(A \\cap B) \\end{aligned} \\tag{5.6} \\end{equation} \\] となります．これを\\(\\bigcup_{i \\in I} A_i\\)に対して一般化して，あらかじめ\\(i \\neq j\\)に対して\\(A_i \\cap A_j = \\emptyset\\)であるような集合族\\(\\mathcal A = \\{ A_i \\}_{i \\in I}\\)を考えます（すなわち\\(\\sqcup_{i \\in I} A_i = \\Omega\\)です），その確率\\(P(\\mathcal A)\\)は次のようになります． \\[ \\begin{equation} P(\\mathcal A) = P \\left( \\bigcup_{i \\in I} A_i \\right) = \\sum_{i \\in I}P(A_i) \\tag{5.7} \\end{equation} \\] ただし\\(I\\)は添え字集合とします． 5.2.2 余事象とその確率 ある事象の補集合を余事象と言います．すなわち\\(A^{c} = \\Omega \\hspace{1mm} \\backslash \\hspace{1mm} A\\)です．明らかに\\(\\Omega = A \\cup A^c\\)かつ\\(A \\cup A^c = \\emptyset\\)ですから， \\[ \\begin{equation} P(A^c) = P(\\Omega) - P(A) = 1 - P(A) \\tag{5.8} \\end{equation} \\] であることがわかります． Exercise 5.4 (余事象の応用) A君とB君がジャンケンを勝ち負けが着くまで行い，これを100回繰り返すとします．この時，A君が少なくとも2勝する確率を求めてください．ただし，A君もB君もジャンケンに勝つ確率は共に\\(1/2\\)とします． 5.2.3 条件付確率 ここでは，条件付確率（conditional probability）というものを考えていきます．現実的な状況として，我々は何かしらの条件の下での確率を考えることは数多くあります．例えば，身体的な性別毎に寿命が違うことが挙げられます．これは，性別という条件の下で人は何歳まで生きるのかという確率を考えていると捉えていることもできるでしょう． これまでの議論と同様に確率を集合に対して定義するという立場を取ります．いまある一つの事象\\(B \\subset \\Omega\\)を考えます．そして，\\(\\Omega\\)の取り方によって\\(B\\)の確率がどのように変わるのかを考えていきます．いま\\(^\\forall e_i\\)に対して\\(0 \\leq P(e_i) \\leq 1\\)かつ\\(P(\\Omega) = 1\\)となるように確率が定められているわけですから，これをそのまま使って\\(B = \\Omega_B\\)という新たな全体集合を定めた上で\\(A \\subset \\Omega_B\\)という部分集合を考えます（\\(\\Omega\\)の部分集合\\(B=\\Omega_B\\)のさらなる部分集合です）．また，\\(\\Omega\\)上に定められた確率と\\(\\Omega_B\\)上に定められた確率を明確に区別するために以降はそれぞれ\\(P\\)と\\(P_B\\)という記号を使うことにします． さて，\\(P_B\\)をこれまで述べてきた確率の定義を満たすように定めたいわけですが \\[ P_B(A) = \\sum_{e_i \\in A} P(e_i) \\] としてしまうと，\\(A \\neq \\Omega\\)であれば\\(P_B(B) = P_B(\\Omega_B) = \\sum_{e_i \\in B} P(e_i) = P(B) &lt; 1\\)となり，全体集合に対する確率が1未満になってしまいます．そこで，\\(^\\forall e_i, e_j \\in \\Omega_B\\)に対して \\[ \\frac{P_B(e_i)}{P_B(e_j)} = \\frac{P(e_i)}{P(e_j)} \\] を満たすようにします．これは結局 \\[ P_B(e_i) = \\frac{P_B(e_j)}{P(e_j)} P(e_i) = c P(e_i) \\] と表せるので元の全体集合\\(\\Omega\\)上で定義された\\(e_i\\)に対する確率\\(P(e_i)\\)に定数\\(c\\)を掛けているとみなせます．さらに\\(P_B(\\Omega_B) = 1\\)となるようにしなければ行けないので \\[ \\sum_{e_i \\in \\Omega_B} P_B(e_i) = c \\sum_{e_i \\in B} P(e_i) = 1 \\] となることがわかります．これより \\[ c = \\frac{1}{\\sum_{e_i \\in \\Omega_B} P_B(e_i)} = \\frac{1}{P(\\Omega_B)} \\] と設定してあげれば良いこともわかりました．\\(cP(\\Omega_B) = 1\\)であるので，\\(^{\\forall}e_i \\in \\Omega_B\\)について\\(0 \\leq P_B(e_i) \\leq 1\\)を満たすこともわかります．故に\\(A \\subset \\Omega_B ( = B)\\)について確率は \\[ P_B(A) = \\sum_{e_i \\in A} P_B(e_i) = \\frac{1}{P(B)} \\sum_{e_i \\in A} P(e_i) = \\frac{P(A)}{P(\\Omega_B)} \\] という様に，元々\\(\\Omega\\)上で定められた確率を新たな全体集合\\(\\Omega_B\\)の確率で割ってあげれば良いことになります． このような操作を，「事象\\(B\\)を与えた時の\\(A\\)の条件付確率」と呼び\\(P(A|B)\\)と表します．つまり，全体集合\\(\\Omega\\)の\\(^{\\forall}B \\subset \\Omega\\)とその部分集合\\(A \\subset B\\)に関して \\[ P(A|B) = \\frac{P(A)}{P(B)} \\] となります．\\(A \\not\\subset B\\)である場合も\\(A&#39; = A \\cap B\\)に対して条件確率を考えれば良いです． 以上の議論を踏まえて，条件付確率を次のように定義します． Definition 5.2 (条件付確率) 全体集合\\(\\Omega\\)について，\\(^\\forall A, B \\subset \\Omega, P(B) &gt; 0\\)に対して，事象\\(B\\)を与えたときの\\(A\\)の条件確率を次式で定義します． \\[ \\begin{equation} P(A|B) = \\frac{P(A \\cap B)}{P(B)} \\tag{5.9} \\end{equation} \\] 定義から直ちに\\(A,B\\)が互いに疎であれば\\(P(A|B)=0\\)となることが分かります． また，同様に定義から直ちに次の定理を導くことができます． Theorem 5.1 (乗法公式) 条件付確率の定義より\\(P(A \\cap B)\\)について次式が成り立ちます． \\[ \\begin{equation} P(A \\cap B) = P(B)P(A|B) \\tag{5.10} \\end{equation} \\] 条件付確率と関連した概念として，独立を定義します． Definition 5.3 (独立) 全体集合\\(\\Omega\\)について，\\(A, B \\subset \\Omega\\)を考えます．この時，次式が成り立つ時\\(A\\)と\\(B\\)は独立であると言います． \\[ P(A|B) = P(A) \\] 独立とは条件付けした事象が，もう一方の事象の確率に影響しないことを意味しています． Exercise 5.5 (条件付確率と独立) 白玉を2個，黒玉を4個入れた袋があります．この袋から順番に2個の玉を無作為に取り出すとします． 最初に取り出した玉を元に戻さずに次の球を取り出します．この時，最初の玉が白玉である事象を\\(A\\)，次の玉が黒玉である事象を\\(B\\)とします．\\(P(A \\cap B)\\)を求めてください．さらに，これらの事象が独立であるかどうか検証してください． 最初に取り出した玉を元に戻してから次の球を取り出します．この時，最初の玉が白玉である事象を\\(A\\)，次の玉が黒玉である事象を\\(B\\)とします．\\(P(A \\cap B)\\)を求めてください．さらに，これらの事象が独立であるかどうか検証してください． 5.2.4 ベイズの定理 ここでは，ベイズの定理の導出・応用について紹介します． まず事象\\(A\\)と\\(k\\)個の事象\\(B_1, \\ldots, B_k\\)を考えます．ただし，\\(\\{ A \\cap B_i \\}_{i=1}^{k}\\)は\\(A\\)の分割であるとします．つまり \\[ A = \\sqcup A \\cap B_i, \\hspace{5mm} i=1,2,\\ldots,k \\] とします．この時条件付確率の定義と乗法公式を適用すれば \\[ \\begin{equation} \\begin{aligned} P(B_1|A) &amp;= \\frac{P(A \\cap B_1)}{P(A)} \\\\ &amp;= \\frac{P(A \\cap B_1)}{\\sum_{i=1}^{k} P(A \\cap B_i)} \\\\ &amp;= \\frac{P(A|B_1)P(B)}{\\sum_{i=1}^k P(A|B_i)P(B_i)} \\end{aligned} \\tag{5.11} \\end{equation} \\] を得ます．上記の式変形は最初に\\(\\{ B_i \\}_{i=1}^{k}\\)を\\(A\\)の分割となるように上手く取っておいたことで可能になっています．これを一般的に表現したものが次のベイズの定理です． Theorem 5.2 (ベイズの定理) いま\\(A \\cap B_i, \\hspace{3mm} i=1,\\ldots,k\\)が\\(A\\)の分割であるとき，全ての\\(i(1 \\leq i \\leq k)\\)について，次式が成り立ちます． \\[\\begin{equation} P(B_i|A) = \\frac{P(A|B_i)P(B_i)}{\\sum_{i=1}^{k} P(A|B_i)P(B_i)} \\tag{5.12} \\end{equation}\\] Example 5.1 (検査の誤判定) 新型コロナウイルスの感染の有無を調べる検査\\(X\\)を考えましょう．この検査\\(X\\)についてはあらかじめ次のことが分かっています． 実際にコロナウイルスに感染している人に対しては95%の精度で陽性となる コロナウイルスに感染していない人に対しては90%の精度で陰性となる また，日本人のうち0.01%の人がコロナウイルスに感染しているとします．このときある人が検査\\(X\\)を受けて陽性と判定されました．この人が本当にコロナウイルスに感染している確率を求めてみましょう． まず分かっていることを整理し，ベイズの定理の仮定と照らし合わせていきましょう． 知りたいのは「検査\\(X\\)で陽性」という条件のもとで，「本当に感染している確率」ですから事象\\(A\\)を「検査\\(X\\)で陽性」として，事象\\(B_1\\)を「本当に感染していること」としましょう．こうすれば，求めたい確率を\\(P(B_1|A)\\)と表せます． 「検査\\(X\\)で陰性」というのは「検査\\(X\\)で陽性」という事象の余事象と考えられますので，これを\\(A^c\\)と表せます． 次に，\\(\\{ B_i \\}_{i=1}^{k}\\)は\\(A\\)の分割となるようにとる必要がありますが，事象\\(B_2\\)は「本当に感染していないこと」とすれば，あまりなく網羅できることが分かります． 次に，分かっている確率を数式に落とし込んでいきましょう． 「実際にコロナウイルスに感染している人に対しては95%で陽性」は\\(P(A|B_1) = 0.95\\)と表せます． \\(P(A|B_1) = 0.95\\)より\\(P(A|B_2) = 1 - P(A|B_1) = 0.05\\)となります． 「コロナウイルスに感染していない人に対しては90%で陰性」は\\(P(A^c|B_2) = 0.90\\)と表せます． \\(P(A^c|B_2) = 0.90\\)より\\(P(A^c|B_1) = 1 - P(A^c|B_2) = 0.10\\)となります． 日本人のうち0.01%が感染しているとしているのでこれは\\(P(B_1) = 0.0001\\)と表せます． 日本人のうち0.99%は感染していないということなので，これは\\(P(B_2) = 0.9999\\)と表せます． 最後に，求めたい確率はベイズの定理より \\[ P(B_1|A) = \\frac{P(B_1)P(A|B_1)}{P(B_1)P(A|B_1) + P(B_2)P(A|B_2)} \\] となるのでこれを計算すれば， \\[ P(B_1|A) = \\frac{0.0001 \\times 0.95}{0.0001 \\times 0.95 + 0.9999 \\times 0.05} \\simeq 0.00189 \\] となり，0.2%程度であることが分かりました． このようにして病気の検査に求められる精度や，そもそもどんな人に対して検査すべきか等を適切に考慮しなければ本来感染していない人を感染していると勘違いしてしまう可能性が高いことがわかると思います． Exercise 5.6 (検査の誤判定) 新型コロナウイルスの感染の有無を調べる検査\\(X\\)を考えましょう．この検査\\(X\\)についてはあらかじめ次のことが分かっています． 実際にコロナウイルスに感染している人に対しては98%の精度で陽性となる コロナウイルスに感染していない人に対しては85%の精度で陰性となる また，日本人のうち0.03%の人がコロナウイルスに感染しているとします．このときある人が検査\\(X\\)を受けて陽性と判定されました．この人が本当にコロナウイルスに感染している確率を求めてください． Exercise 5.7 (モンティホール問題) 3つの扉があり，そのどれか一つの扉の後ろには賞金100万円が置いてあります．まずゲームの挑戦者は扉を一つだけ選びます．次に司会者が 選ばれていない2つの扉のうち，賞金が置かれていない扉を一つだけ開けます．このとき，挑戦者は残った二つの扉のうちどちらを選ぶ一度だけ選び直すことができます．さて，挑戦者は元の扉を選ぶか，またはもう一方の扉を選ぶかどちらの方が賞金を手にする確率が高いでしょうか．それぞれの確率を求めた上で答えてください． ． "],["r-notebookの書き方.html", "6 R Notebookの書き方 6.1 R Notebookの基本:HTML 6.2 Markdownの基本的な記法 6.3 Rのコードを記述する 6.4 Latex記法", " 6 R Notebookの書き方 R NotebookではMarkdownベースの記法に従い文章を執筆することで，HTMLやPDFへ用意な出力が可能になります． 6.1 R Notebookの基本:HTML R Notebookで記述したドキュメントは，HTMLやPDFなどで出力することができます．PDFを扱う場合は 少々エラーが起こりやすいのでここではHTMLのみに留めて紹介します． 6.1.1 R Notebookファイルを作成する まずR Notebookファイルを作成してみましょう．Rstudioのウィンドウの一番左上にある＋ボタンを押し，R Notebookを選択します．これでR Notebookファイルが作成され新たなウィンドウが表示されます． 6.1.2 R NotebookによるHTMLの生成 新たなR Notebookファイルが表示されたら，そのままツールバーにあるPreviewの横にある下三角ボタンを押し，Knit to HTMLをクリックします．HTMLを生成する前にファイルを保存するように求められますので適当な場所に保存してください． すると，Rのプレビュー機能によりHTMLが表示されます．これでR NotebookによるHTMLの生成は完了です． 以降は実際にR Notebookの中身を書き換えて再度knit to HTMLを実行することで更新されたHTMLを生成していくことになります． 生成されたHTMLファイルは，R Notebookファイルがあるところと同じフォルダに保存されます． 6.1.3 YAMLヘッダー R Notebookファイルの先頭には以下のようなコードブロックがあったと思います．これをYAMLヘッダーと呼びます．この部分に適切にノートブックの設定を記述することで生成されるHTMLのフォーマットを変更することができます．その一部をここでは紹介します． デフォルトで記述されているYAMLヘッダー． --- title: &quot;R Notebook&quot; output: html_notebook --- YAMLヘッダー内ではkey: valueの形式で記述します．入れ子にする場合は key1: nested-key1: value1 nested-key2: value2 のように記述します． 著者名とレポート日付はこのように記述します． author: &quot;your name&quot; date: &quot;2021年12月31日&quot; 次に，レポートの目次表示をする場合は以下のように記述します． output: html_document: toc: true またHTML上で画面内に常に目次を表示するようなfloating tocを利用するには output: html_document: toc: true toc_float: true とすれば有効になります． 最後に，これまで紹介してきたヘッダーを合わせると以下のようなYAMLヘッダーになります． --- title: &quot;Report title&quot; author: &quot;Your name&quot; date: &quot;YYYY-MM-DD&quot; output: html_document: toc: true toc_float: true --- レポートを提出する際は，最低限名前と日付は入れておきましょう． 6.2 Markdownの基本的な記法 ここではMarkdownと呼ばれる記法について紹介します．Markdown自体は色々なサービスでも採用されている 記法です．その中でも基本的な見出し・箇条書き（番号あり・なし）コードブロック・その他書式設定について紹介していきます． 6.2.1 見出し 行頭に#をつけることで見出しとして出力することができます．まだ#の数を増やすと入れ子にすることができます． # 見出し1 ## 見出し2 ### 見出し3 6.2.2 箇条書き 箇条書きについては，以下のように記述します． - item1 - item2 - item3 - item4 - item5 - item6 結果は以下の通りです． item1 item2 item3 item4 item5 item6 番号付きにする場合は次のようにします． 1. item1 1. item2 1. item3 1. item4 1. item5 1. item6 結果は以下の通りです． item1 item2 item3 item4 item5 item6 6.2.3 コードブロック プログラムコードを通常のフォントで表示すると視認性が著しく失われることがあります（ほとんどの場合はそうです）． 例えば a &lt;- function(x){ res &lt;- x^3 res += 10 } a(28) という簡単なRのコードでも少し読みにくいことがわかると思います． そこでMarkdownではプログラムコードはそれに適した書式で表示してくれる記法を用意しています． 文中においては```で囲み，独立してコードブロックを記述したい場合は ``` コードを記述 ``` とします． 例を示します．文中にコードprogram codeを表示する．program codeの部分の表示が少し変わっているのがわかると思います． これが文中のコード表記です． 次に，複数行にわたるコードブロックの例を示します． a &lt;- function(x){ res &lt;- x^3 res += 10 return(res) } a(28) これはR Notebook内では ``` a &lt;- function(x){ res &lt;- x^3 res += 10 return(res) } ``` と記述しています．プログラムとして読むにあたりかなり読みやすくなっていることがわかります． 6.2.4 その他の書式設定 最後に，太字・斜体・リンクについて紹介します．太字にする場合**で太字にしたい文字列を囲みます．すると，このように太字になります．また，車体にしたい場合は*で文字列を囲みます．斜体になります． 次に，ある文字列にリンクを貼りたい場合は[文字列](URL)と記述することでリンク付き文字列として出力できます． 例えば，「自由学園」という文字列に自由学園のHPのリンクを貼る場合は[自由学園のHPはこちら](https://jiyu.ac.jp)とすれば 自由学園のHPはこちら のように，リンク付き文字列となります． 6.3 Rのコードを記述する Rmarkdown中にチャンクと呼ばれるコードブロックを記述すると，そのコードブロック内でRを実行することができます．例えば下記のように記述してみると ```{r} summary(cars) ``` というようにsummary(cars)が実行され，その結果を表示することができます． summary(cars) ## speed dist ## Min. : 4.0 Min. : 2.00 ## 1st Qu.:12.0 1st Qu.: 26.00 ## Median :15.0 Median : 36.00 ## Mean :15.4 Mean : 42.98 ## 3rd Qu.:19.0 3rd Qu.: 56.00 ## Max. :25.0 Max. :120.00 さらに文章中でも実行することができます．その場合は例えば文中に `r Sys.Date()` というようにすれば実行できます．Sys.Date()という関数はその日の日付を返す関数です．実際にやってみると次のようになります． 「今日の日付は2021-10-15です．」 6.4 Latex記法 Rmarkdown中ではLatexを扱うことができます．Latexについては詳細は割愛しますが，Latexは数式に特化した記法で数式を綺麗に表示することができます．ここでは，本講義で扱うような記号についてのLatex表記を紹介します．Latexの表記自体は数多くあるため全てを紹介することはできませんが，興味のある人はウェブや書籍で調べてみてください． 6.4.1 基本的な使い方 Latexを扱うためには$か$$でLatex記法を囲む必要があります．文中で数式を各場合は$で囲めばよいです．例えば$a + b = c$という記述を文中ですることで「\\(a + b = c\\)」という結果を得ます． 数式を独立させる場合や複数行にわたる場合は$$で囲みます．記述例としては $$ f(x) = ax^2 + bx + c \\\\ = h $$ とすることで \\[ f(x) = ax^2 + bx + c \\\\ = h \\] という結果を得ます．\\\\は改行を意味する記号です． 6.4.2 複数の数式を整列させる：align, gather 複数行にわたり数式を記述した際，数式を整列させるためにalignが便利です． \\begin{align} ここに数式を記述する \\end{align} このように\\begin{align}と\\end{align}で数式を挟みます． \\[ \\begin{align} f(x) = x^2 + x + 1 \\end{align} \\] また，整列させる場合には各行の揃えたい部分に&amp;を挿入します． $$ \\begin{align} f(x) &amp;= x^2 + x + 1 \\\\ &amp;= (x + 0.5)^2 + 0.75 \\end{align} $$ \\[ \\begin{align} f(x) &amp;= x^2 + x + 1 \\\\ &amp;= (x + 0.5)^2 + 0.75 \\end{align} \\] このように，それぞれの行において&amp;=としているので=の位置が同じになるように調整されます． 各行を中央揃えにしたい場合はgatherを使います． \\[ \\begin{gather} f(x) = a + b \\\\ g(x) = a + b + c \\\\ h(x) = a + b + c + d \\end{gather} \\] 6.4.3 基本的な表記 意味 Latexコード 表示 足算 + \\(+\\) 引算 - \\(-\\) 掛算 \\times \\(\\times\\) 割算 \\div \\(\\div\\) 分数 \\frac{a}{b} \\(\\frac{a}{b}\\) プラスマイナス \\pm \\(\\pm\\) マイナスプラス \\mp \\(\\mp\\) 総和 \\sum_{i=1}^{n} \\(\\sum_{i=1}^{n}\\) 総乗 \\prod_{i=1}^{n} \\(\\prod_{i=1}^{n}\\) 階乗 n! \\(n!\\) 点 \\dot \\(\\cdot\\) 中段点列 \\cdots \\(\\cdots\\) 下段点列 \\ldots \\(\\ldots\\) 関数 f(x) \\(f(x)\\) 無限大 \\infty \\(\\infty\\) 下付き文字 a_{11}$ \\(a_{11}\\) 上付き文字 b_{\\alpha} \\(b_{\\alpha}\\) 上下付き文字 a_{i}^{(k)} \\(a_{i}^{(k)}\\) 6.4.4 微分積分 意味 Latexコード 表示 微分 \\frac{dy}{dx} \\(\\frac{dy}{dx}\\) 微分 f'(x) \\(f&#39;(x)\\) 微分 \\frac{\\partial f}{\\partial x} \\(\\frac{\\partial f}{\\partial x}\\) 積分 \\int \\(\\int\\) ２重積分 \\iint \\(\\iint\\) \\(n\\)重積分 \\idotsint \\(\\idotsint\\) 6.4.5 論理演算 意味 Latexコード 表示 ならば \\Rightarrow \\(\\Rightarrow\\) 同値 \\Leftrightarrow \\(\\Leftrightarrow\\) 否定 \\lnot \\(\\lnot\\) 論理積 \\land \\(\\land\\) 論理和 \\lor \\(\\lor\\) 排他的論理和 \\oplus \\(\\oplus\\) 任意の \\forall \\(\\forall\\) 存在する \\exists \\(\\exists\\) 定義記号 := \\(:=\\) 6.4.6 代表的な集合 意味 Latexコード 表示 自然数 \\mathbb N \\(\\mathbb N\\) 整数 \\mathbb Z \\(\\mathbb Z\\) 正の整数 \\mathbb Z^+ \\(\\mathbb Z^+\\) 有理数 \\mathbb Q \\(\\mathbb Q\\) 無理数 \\mathbb R \\setminus \\mathbb Q \\(\\mathbb R \\setminus \\mathbb Q\\) 実数 \\mathbb R \\(\\mathbb R\\) 複素数 \\mathbb C \\(\\mathbb C\\) 6.4.7 集合演算 意味 Latexコード 表示 含む \\in \\(\\in\\) 含まない \\notin \\(\\notin\\) 部分集合である \\subset \\(\\subset\\) 部分集合ではない \\not\\subset \\(\\not\\subset\\) 共通部分 \\cap \\(\\cap\\) 共通部分 \\bigcap \\(\\bigcap\\) 和集合 \\cup \\(\\cup\\) 和集合 \\bigcup \\(\\bigcup\\) 分割 \\sqcup \\(\\sqcup\\) 分割 \\bigsqcup \\(\\bigsqcup\\) 差集合 \\setminus \\(\\setminus\\) 空集合 \\emptyset \\(\\emptyset\\) 空集合 \\varnothing \\(\\varnothing\\) 冪集合 \\mathfrak{P}(A) \\(\\mathfrak{P}(A)\\) 冪集合 \\mathcal{P}(A) \\(\\mathcal{P}(A)\\) 6.4.8 場合の和・確率 意味 Latexコード 表示 順列 {}_n P_r \\({}_n P_r\\) 組み合わせ {}_n C_r \\({}_n C_r\\) 組み合わせ n \\choose r \\(n \\choose r\\) 確率変数\\(X\\)が標準正規分布に従う X \\sim N(0,1) \\(X \\sim N(0,1)\\) 独立に同一の分布に従う(i.i.d) \\overset{\\text\\small\\textrm{iid}}{\\sim} \\(\\overset{\\textrm{iid}}{\\sim}\\) 6.4.9 ベクトルと行列 縦・横ベクトル $$ \\begin{align} &amp;\\begin{pmatrix} a &amp; b &amp; c \\end{pmatrix} \\\\ &amp;\\begin{pmatrix} a \\\\ b \\\\ c \\end{pmatrix} \\end{align} $$ \\[ \\begin{gather} &amp;\\begin{pmatrix} a &amp; b &amp; c \\end{pmatrix} \\\\ &amp;\\begin{pmatrix} a \\\\ b \\\\ c \\end{pmatrix} \\end{gather} \\] 行列 $$ \\begin{gather} &amp;\\begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ \\end{pmatrix} \\\\ \\\\ &amp;\\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ \\end{bmatrix} \\\\ \\\\ &amp;\\begin{matrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ \\end{matrix} \\end{gather} $$ \\[\\begin{gather} &amp;\\begin{pmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ \\end{pmatrix} \\\\ \\\\ &amp;\\begin{bmatrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ \\end{bmatrix} \\\\ \\\\ &amp;\\begin{matrix} a_{11} &amp; a_{12} &amp; a_{13} \\\\ a_{21} &amp; a_{22} &amp; a_{23} \\\\ \\end{matrix} \\end{gather}\\] 6.4.10 場合分け $$ f(x) = \\begin{cases} 1 &amp; \\text{if} \\hspace{3mm} 0 \\leq x \\leq 1 \\\\ 0 &amp; \\text{else} \\end{cases} $$ \\[ f(x) = \\begin{cases} 1 &amp; \\text{if} \\hspace{3mm} 0 \\leq x \\leq 1 \\\\ 0 &amp; \\text{else} \\end{cases} \\] 6.4.11 ギリシャ文字 意味 大文字 小文字 表示 アルファ A \\alpha \\(A, \\alpha\\) ベータ B \\beta \\(B, \\beta\\) ガンマ \\Gamma, \\varGamma \\gamma \\(\\Gamma, \\varGamma,\\gamma\\) デルタ \\Delta, \\varDelta \\delta \\(\\Delta, \\varDelta, \\delta\\) イプシロン E \\epsilon, \\varepsilon \\(E, \\epsilon, \\varepsilon\\) ゼータ Z \\zeta \\(Z, \\zeta\\) エータ H \\eta \\(H, \\eta\\) シータ \\Theta, \\varTheta \\theta, \\vartheta \\(\\Theta, \\varTheta, \\theta, \\vartheta\\) イオタ I \\iota \\(I, \\iota\\) カッパ K \\kappa, \\varkappa \\(K, \\kappa, \\varkappa\\) ラムダ \\Lambda, \\varLambda \\lambda \\(\\Lambda, \\varLambda, \\lambda\\) ミュー M \\mu \\(M, \\mu\\) ニュー N \\nu \\(N, \\nu\\) クシー・グザイ \\Xi,\\varXi \\xi \\(\\Xi, \\varXi, \\xi\\) オミクロン O \\o \\(O, o\\) パイ \\Pi,\\varPi \\pi, \\varpi \\(\\Pi, \\varPi, \\pi, \\varpi\\) ロー \\P \\rho, \\varrho \\(P, \\rho, \\varrho\\) シグマ \\Sigma, \\varSigma \\sigma, \\varsigma \\(\\Sigma, \\varSigma, \\sigma, \\varsigma\\) タウ T \\tau \\(T, \\tau\\) ウプシロン \\Upsilon, \\varUpsilon \\upsilon \\(\\Upsilon, \\varUpsilon, \\upsilon\\) ファイ \\Phi, \\varPhi \\phi, \\varphi \\(\\Phi, \\varPhi, \\phi, \\varphi\\) カイ X \\chi \\(X, \\chi\\) プサイ \\Psi, \\varPsi \\psi \\(\\Psi, \\varPsi, \\psi\\) オメガ \\Omega, \\varOmega \\omega \\(\\Omega, \\varOmega, \\omega\\) "],["集合.html", "7 集合 7.1 集合の定義 7.2 基本的な集合 7.3 集合の要素に関する記号 7.4 部分集合と包含関係 7.5 冪（べき）集合 7.6 集合の演算 ", " 7 集合 集合の言葉に慣れると，数学的な説明がよりわかりやすくかつシンプルに理解できるようになります．ここでは言葉として「集合」を扱うことに慣れるために種々の概念を紹介していきます． 7.1 集合の定義 集合とは「ものの集まり」です．この「もの」は基本的にどんなものでも構いません．数学では必然的に「数」を扱うことが多いですが場合によっては文字（人や果物の名前など）の場合もあるでしょう． また関数や集合そのものも集まりの対象として捉えることができます．例えば，学校の「クラス」などは人の集合がある条件を満たす場合の呼び方と捉えることができるでしょう．また「家族」自体は人の集合ですが，その家族の集合も考えることができますね．そしてこの「もの」のことと要素とか元と呼びます．ここでは「要素」を採用しましょう． Definition 7.1 (集合) 集合とは要素の集まりです．要素はどんなものでも構いませんが，どんな要素と集合を考えてもその要素が集合に含まれるのか，含まれないのかは常にどちらかに決まります．ただし，集合は自身を要素には含まないものとします． 各要素\\(x\\)がある集合\\(X\\)に含まれることを\\(x \\in X\\)と表します．逆に含まれないことは\\(x \\notin X\\)と表します． 集合の要素は常にある集合に含まれるか，含まれないかのどちらかが確定しなくてはいけません．これは集合を扱う上で重要なポイントです．つまり，ある集合\\(X\\)に対して要素\\(x\\)が\\(x \\in X\\)かつ\\(x \\notin X\\)どちらも成り立つということは考えません． 集合を記述する場合は各要素を\\(\\{ \\}\\)の中に\\(,\\)で区切って列挙します．例えば，\\(1\\)から\\(5\\)までの整数を要素に持つ集合\\(A\\)は \\[ A = \\{ 1,2,3,4,5 \\} \\] と記述します．集合の要素が多い場合は次のように省略するか，\\(|\\)で区切って要素に共通するルールを記述します． \\[ \\begin{align} A^\\prime &amp;= \\{ 1,2,\\ldots,49,50 \\} \\\\ A^\\prime &amp;= \\{ n | 1 \\leq n \\leq 50, n \\in \\mathbb N\\} \\end{align} \\] \\(1,2,\\ldots\\)のように記述されている場合は，要素が無限に続いていることを意味しています．また\\(\\mathbb N\\)は全ての自然数の集合を表します． 7.2 基本的な集合 集合を扱う上で知っておくべき基本的な集合を紹介していきます． Example 7.1 (空集合) 要素を１つも持たない集合を空集合と呼び，\\(\\emptyset\\)と書きます．すなわちどんな要素\\(x\\)を持ってきても\\(x \\notin \\emptyset\\)が成り立ちます． Example 7.2 (よく使われる集合) 自然数・整数・有理数・実数についてそれぞれ全体のなす集合を表す記号を定義します．これらはよく使われるので是非覚えてください． 集合 記号 自然数 \\(\\mathbb N\\) 整数 \\(\\mathbb Z\\) 正の整数 \\(\\mathbb Z^{+}\\) 負の整数 \\(\\mathbb Z^{-}\\) 有理数 \\(\\mathbb Q\\) 実数 \\(\\mathbb R\\) Example 7.3 (実数の区間) 実数の区間は中学，高校の数学で扱ったと思います．これも集合の言葉で言えば実数の集合です．すなわち\\(a,b \\in \\mathbb R\\)で\\(a &lt; b\\)のとき，\\(a\\)以上\\(b\\)以下である全ての実数のなす集合を\\([a,b]\\)と表します．これを閉区間ともよびます．これは次のように記述することもできます． \\[ [a,b] = \\{ x : x \\in \\mathbb R, a \\leq x \\leq b \\} \\] また，\\(a\\)より大きく\\(b\\)より小さい全ての実数のなす集合を\\((a,b)\\)と表し，これを開区間とよびます．これは次のように記述できます． \\[ (a,b) = \\{ x : x \\in \\mathbb R, a &lt; x &lt; b \\} \\] これらを組み合わせて，\\(a \\leq x &lt; b\\)といった条件の集合を考えることもでき，これを半開区間と呼んだりします．また無限大を表す\\(\\infty\\)を使って \\[ (a, \\infty) = \\{ x : x \\in \\mathbb R, a &lt; x \\} \\] \\[ (-\\infty, b) = \\{ x : x \\in \\mathbb R, x &lt; b \\} \\] という集合を記述することもできます．ここで，無限大はある特定の数を意味しないので\\([-\\infty,\\infty]\\)のようには表さないことに注意してください． 7.3 集合の要素に関する記号 ある要素\\(x\\)が集合\\(X\\)に含まれることを\\(x \\in X\\)と記述しましたが，ある集合\\(X\\)の要素\\(x\\)について述べる時，それが\\(X\\)に含まれるどんな要素でも良いのか，特定の要素の場合だけを考えるかの２つの場合があります． そのような場合に便利な記法があるので紹介します． Definition 7.2 (全称記号と存在記号) \\(X\\)に含まれる任意の要素であることを \\[ {}^\\forall x \\in X \\] と表します．また，そのような要素\\(x\\)が少なくとも一つは存在することを \\[ {}^\\exists x \\in X \\] と表します． 例えば，自明ですが\\(A = \\{x:x \\in \\mathbb N, x \\leq 50 \\}\\)については，\\({}^\\forall a \\in A\\)に対して\\(a \\leq 50\\)が成り立ちます．一方\\(a \\leq 10\\)という条件は任意の\\(A\\)の要素について成り立つわけではありませんが少なくとも１つはそのような要素は存在するわけですから，\\({}^\\exists x \\in A\\)で\\(a \\leq 10\\)が成り立ちます． 7.4 部分集合と包含関係 集合と集合の関係で最も基本的なもので包含関係が挙げられます．すなわち，一方の集合が他方に含まれているかどうかです． Definition 7.3 (部分集合と包含関係) 集合\\(A,B\\)について，\\({}^\\forall a \\in A\\)が\\(a \\in B\\)であるとき，\\(B\\)は\\(A\\)を包含する，または含むといいます． \\(B\\)が\\(A\\)を含む時，\\(A\\)は\\(B\\)の部分集合であるといい\\(A \\subset B\\)と表します． 次に，集合についての等号（\\(=\\)）について次のように定義します． Definition 7.4 (集合の等号成立) 集合\\(A,B\\)について，\\(A \\subset B\\)かつ\\(B \\subset A\\)が成り立つ時，集合\\(A\\)と\\(B\\)は等しいといい\\(A = B\\)と表します． また，集合\\(A\\)と\\(B\\)が等しくないとき\\(A \\neq B\\)と表します． 最後に真部分集合について次のように定義しておきます． Definition 7.5 (真部分集合) 集合\\(A,B\\)について\\(A \\subset B\\)かつ\\(A \\neq B\\)が成り立つ時，\\(A\\)は\\(B\\)の真部分集合であるといいます． Example 7.4 集合\\(A, B, C\\)をそれぞれ次のように定義します． \\[ \\begin{aligned} A &amp;= \\{ 1,2,3,4 \\} \\\\ B &amp;= \\{ 1,2,3,4,5 \\} \\\\ C &amp;= \\{ 4,3,2,1 \\} \\end{aligned} \\] このとき，\\(A \\subset B\\)と\\(A \\subset C\\)両方成り立っていますが，\\(A\\)は\\(B\\)の真部分集合である一方，\\(A\\)は\\(C\\)の真部分集合ではありません． Exercise 7.1 次の３つの集合について真部分集合を一つあげてください． \\(\\mathbb N\\) \\(\\mathbb R\\) \\(\\mathbb Q\\) 7.5 冪（べき）集合 ある集合\\(A\\)に対して，その部分集合を元とする集合を考えることができます．特に部分集合全体のなす集合はよく扱われます．そこで，このような集合を冪（べき）集合と呼び次のように定義します． Definition 7.6 (冪（べき）集合) 集合\\(A\\)に対して，その部分集合の全体のなす集合を\\(A\\)の冪集合と呼び，\\(2^A\\)と書きます．すなわち \\[ 2^A = \\{ X : X \\subset A \\} \\] です． 冪集合の「冪」は冪乗から来ているが，\\(2^A\\)と表すのは部分集合全体が\\(A\\)に含まれる全ての要素がそれぞれ含まれるか含まれないかの２通りの組み合わせで表せることから来ています． また，冪集合のように集合を元とする集合のことを集合族とよび明確に集合と分ける流儀もあります． Example 7.5 (冪集合の例) 集合\\(A = \\{1,2,3\\}\\)について，その冪集合\\(2^A\\)は次のようになります． \\[ 2^A = \\{ \\emptyset, \\{ 1 \\}, \\{ 2 \\}, \\{ 3 \\},\\{ 1,2 \\}, \\{ 2,3 \\}, \\{ 1,3 \\}, \\{ 1,2,3 \\} \\} \\] Exercise 7.2 集合\\(A = \\{ a,b,c,d,e,f \\}\\)について，その冪集合の要素がいくつになるか計算してください． 7.6 集合の演算 既にいくつか集合同士の関係を記述する記号を紹介しましたが，ここでは集合同士の演算を定義していきます． Definition 7.7 (共通部分と和集合) 集合\\(A,B\\)について，\\(x \\in A\\)かつ\\(x \\in B\\)であるような要素\\(x\\)全体のなす集合を\\(A\\)と\\(B\\)の共通部分・共通集合とよび\\(A \\cap B\\)と書きます． すなわち \\[ A \\cap B = \\{x:x \\in A \\hspace{3mm} \\rm{and} \\hspace{3mm} x \\in B \\} \\] です．また，\\(y \\in A\\)または\\(y \\in B\\)であるような要素\\(y\\)全体のなす集合を和集合と呼び\\(A \\cup B\\)と書きます．すなわち \\[ A \\cup B = \\{x:x \\in A \\hspace{3mm} \\rm{or} \\hspace{3mm} x \\in B \\} \\] です． つぎに，引き算にあたる差集合を次のように定義します． Definition 7.8 (差集合) 集合\\(A,B\\)について，\\(x \\in A\\)かつ\\(x \\notin B\\)であるような要素\\(x\\)全体のなす集合を\\(A \\hspace{1mm} \\backslash \\hspace{1mm} B\\)と表します． 差集合と定義は似ていますが，補集合を次のように定義します． Definition 7.9 (補集合) ある集合\\(\\Omega\\)を興味の対象である要素全てを含む集合，すなわち全体集合とするとき，\\(A \\subset \\Omega\\)であるような集合\\(A\\)について， \\(\\Omega \\hspace{1mm} \\backslash \\hspace{1mm} A\\)を\\(A\\)の補集合といいます．これを\\(A^c\\)と表します．すなわち \\[ A^c = \\Omega \\hspace{1mm} \\backslash \\hspace{1mm} A = \\{x:x \\in \\Omega, x \\notin A \\} \\] です． 共通部分や和集合については，演算の順番によらず結果は同じになりますが，差集合については演算の順番により結果が変わることに注意してください． 実際，\\(A = \\{ 1,3,5,6 \\}\\)，\\(B = \\{ 1,2,3 \\}\\)とすると \\[ \\begin{aligned} A \\hspace{1mm} \\backslash \\hspace{1mm} B &amp;= \\{ 5,6 \\} \\\\ B \\hspace{1mm} \\backslash \\hspace{1mm} A &amp;= \\{ 2 \\} \\end{aligned} \\] となります． 包含関係と補集合について次の定理が成り立ちます． Theorem 7.1 全体集合\\(\\Omega\\)とその部分集合\\(A,B\\)について，\\(A \\in B\\)ならば\\(B^c \\in A^c\\)が成り立ちます． これはベン図を用いればすぐにわかるでしょう． Theorem 7.2 (ド・モルガンの法則) 全体集合\\(\\Omega\\)とその部分集合\\(A,B\\)について，\\((A \\cap B)^c = A^c \\cup B^c\\)が成り立ちます． また，\\((A \\cup B)^c = A^c \\cap B^c\\)も成り立ちます． 証明は割愛します． 7.6.1 添字集合 共通部分\\(\\cap\\)と和集合\\(\\cup\\)を有限個の集合に対する演算に拡張します．いま\\(n\\)個の集合があるとして，それらを\\(A_1, A_2, \\ldots, A_n\\)と表すことにしましょう．この時\\(A\\)の左下についている文字（ここでは数字）を添字（そえじ）と呼びます．そして，集合族\\(\\mathcal A = \\{ A_1, A_2, \\ldots, A_n \\}\\)を考えましょう．このとき添字の集合\\(I = \\{ 1,2,\\ldots,n \\}\\)をそのまま集合族\\(\\mathcal A\\)の添字集合と呼びます．添字集合を用いることで，要素の多い集合や集合族の記述が簡単になります． 例えば，\\(\\mathcal A = \\{ A_i : i \\in I \\}\\)で\\(I = \\{i:i \\in \\mathbb N, i &lt;= n \\}\\)とかけます． 添字集合は数字でなくでも\\(a,b,c\\)のようなものでも良いですしもっと複雑なものでも構いません．これはあくまで要素を区別するための記号です．記述のしやすさという観点でみれば，自然数を使うのが良いでしょう．また，添字集合の要素は有限個でも無限個でも構いません．書き方として，\\(\\{ x_i \\}_{i \\in \\mathbb N}\\)のように添字集合の定義をそのまま左下に記述するケースもありますし，より明白な場合は\\({x_s}_{0 \\leq s \\leq 1}\\)などと略す書き方もあります． 7.6.2 集合族に対する演算 集合族について，共通部分と和集合の演算を次のように定義します． Definition 7.10 (集合族の共通部分と和集合) 集合族\\(\\mathcal A = \\{A_i\\}_{i \\in I}\\)について，その共通部分を \\[ \\bigcap_{i \\in I} A_i = \\{ x: {}^\\forall i \\in I, x \\in A_i \\} \\] と定義します．同様にその和集合を \\[ \\bigcup_{i \\in I} A_i = \\{ x: {}^\\exists i \\in I, x \\in A_i \\} \\] と定義します． この記号については，\\(\\sum_{i=1}^{n}\\)と同じように表記されることもあります． \\[ \\bigcap_{i=1}^{n} A_i, \\ \\bigcap_{i=1}^{\\infty} A_i, \\ \\bigcup_{i=1}^{n} A_i, \\ \\bigcup_{i=1}^{\\infty} A_i \\] さらに，集合族の和集合の特別な場合として直和の概念を定義しておきます． Definition 7.11 (集合の分割と直和) 集合族\\(\\mathcal A\\)の和集合\\(A = \\bigcup_{i \\in I} A_i\\)について，どの相異なる２つの集合\\(A_j, A_k(j \\neq k)\\)についても\\(A_j \\cap A_k = \\emptyset\\)となるとき，その和集合\\(A\\)は\\(\\{ A_i \\}_{i \\in I}\\)で分割されているといいます．また逆に，\\(A\\)は\\(\\{ A_i \\}_{i \\in I}\\)らの直和であるといいます． このことを記号を用いて \\[ \\bigsqcup_{i \\in I} A_i \\] と表します．他にも，\\(A_1 \\sqcup \\cdots \\sqcup A_n\\)のように列挙して表すこともあります． 典型的な例を以下に示します． Example 7.6 (無限個の区間の共通部分と和集合) \\(n \\in \\mathbb N\\)について，実数の区間\\(A_n = [0, 1/n]\\)を考えます．このような集合全体のなす集合族\\(\\{ A_n \\}_{n \\in \\mathbb N}\\)について \\[ \\bigcap_{n \\in \\mathbb N} A_n = \\bigcap_{n \\in \\mathbb N} [0, 1/n] = \\{ 0 \\} \\] となります．また \\[ \\bigcup_{n \\in \\mathbb N} = [0, 1] \\] も成り立ちます． Exercise 7.3 例7.6を確かめてください． 最後にド・モルガンの法則の集合族版を以下に紹介します． Theorem 7.3 (ド・モルガンの法則) 集合族\\(\\mathcal A\\)について，以下が成り立ちます． \\[ \\begin{aligned} \\left( \\bigcap_{i \\in I} A_i \\right)^c &amp;= \\bigcup_{i \\in I} A_i^c \\\\ \\left( \\bigcup_{i \\in I} A_i \\right)^c &amp;= \\bigcap_{i \\in I} A_i^c \\end{aligned} \\] "],["命題.html", "8 命題 8.1 命題の組み合わせ 8.2 十分条件と必要条件 8.3 真偽値表 8.4 恒真命題と同値な命題 8.5 全称命題と存在命題", " 8 命題 「命題」とは真偽のどちらか一方のみが成立するものを指します．例えば \\(100\\)より大きな自然数が存在する \\(57\\)は素数である などはそれぞれ真偽のどちらか一方は成立し，他方は不成立となるのでこれは命題です．しかし あの人は男である といったものは命題ではありません（身体的には男性だが性自認は女性というケースもある）． 8.1 命題の組み合わせ 命題の組み合わせ方は以下の４つに限られます．ここで\\(P, Q\\)をそれぞれ命題として \\(\\neg P\\):\\(P\\)でない \\(P \\land Q\\):\\(P\\)かつ\\(Q\\) \\(P \\lor Q\\):\\(P\\)または\\(Q\\) \\(P \\Rightarrow Q\\):\\(P\\)ならば\\(Q\\) です．これらを幾度も繰り返して複雑な命題を作ることもできます． 便宜上，\\(P \\Leftrightarrow Q\\)は\\((P \\Rightarrow Q) \\land (Q \\Rightarrow P)\\)を意味する記号として良く使われます． 8.2 十分条件と必要条件 \\(P \\Rightarrow Q\\)が成立するとき，\\(P\\)は\\(Q\\)の十分条件，\\(Q\\)は\\(P\\)の必要条件と言います．また \\(P \\Leftrightarrow Q\\)であるとき，\\(P\\)と\\(Q\\)は互いに必要十分条件である，と言います． Exercise 8.1 命題\\(P_1, P_2, P_3\\)に対して次の命題を翻訳してください． \\[ ((\\neg P_1) \\land P_2) \\lor (P_3 \\Rightarrow (P_1 \\lor P_2)) \\] 8.3 真偽値表 命題の操作を簡潔にまとめた表を以下に示しておきます．ここで\\(T\\)は真，\\(F\\)は偽を表します． \\(P\\) \\(Q\\) \\(\\neg P\\) \\(P \\land Q\\) \\(P \\lor Q\\) \\(P \\Rightarrow Q\\) \\(P \\Leftrightarrow Q\\) \\(T\\) \\(T\\) \\(F\\) \\(T\\) \\(T\\) \\(T\\) \\(T\\) \\(T\\) \\(F\\) \\(F\\) \\(F\\) \\(T\\) \\(F\\) \\(F\\) \\(F\\) \\(T\\) \\(T\\) \\(F\\) \\(T\\) \\(T\\) \\(F\\) \\(F\\) \\(F\\) \\(T\\) \\(F\\) \\(F\\) \\(T\\) \\(T\\) 8.4 恒真命題と同値な命題 Definition 8.1 (恒真命題) 有限個の命題\\(P_1, \\ldots, P_n\\)と命題の組み合わせによって作られた命題\\(P\\)を\\(P(P_1,\\ldots,P_n)\\)と表します． このとき，命題\\(P(P_1,\\ldots,P_n)\\)が各命題\\(P_1,\\ldots,P_n\\)の真偽によらず常に真であるとき，\\(P\\)は恒真命題であるといいます． また，トートロジーであるいう場合もあります． Example 8.1 命題\\(P\\)に対して，\\(P \\Rightarrow P\\)という命題は恒真命題です． Example 8.2 (排中律) 命題\\(P\\)に対して，命題\\(P \\lor (\\neg P)\\)は恒真命題です．この恒真命題を排中律といいます． Definition 8.2 (同値な命題) 有限個の命題\\(P_1, \\ldots, P_n\\)から作られた２つの命題\\(P(P_1,\\ldots,P_n)\\)と\\(Q(P_1,\\ldots,P_n)\\)について，命題\\(P \\Leftrightarrow Q\\)が恒真命題であるとき，この２つの命題は同値であるといい，\\(P \\equiv Q\\)と表します． これより，命題\\(P,Q\\)が同値であればどちらか一方の真偽を調べることで他方の真偽を確認できます．数学の証明などでよく使われるテクニックを紹介しましょう． Example 8.3 (背理法) どんな命題\\(P\\)の真偽も命題\\(\\neg(\\neg P)\\)と一致します．すなわち，\\(P \\equiv \\neg(\\neg P)\\) 背理法は，証明したい命題\\(P\\)の否定の命題\\(\\neg P\\)を考察していき，この命題を評価することで最終的に\\(P\\)を確かめる方法です． Example 8.4 (対偶) どんな２つの命題\\(P,Q\\)に対しても，命題\\(P \\Rightarrow Q\\)と命題\\((\\neg Q) \\Rightarrow (\\neg P)\\)の真偽は一致します．これを対偶といいます． 命題によっては対偶を考えることで証明がより簡単に行える場合があります． 8.5 全称命題と存在命題 8.5.1 集合と命題関数 集合の表し方について改めて考えていきましょう．ある集合\\(\\Omega\\)に対して\\(x \\in \\Omega\\)を含む主張\\(P(x)\\)が，各\\(x\\)に対して命題であるとき，\\(\\Omega\\)上の条件と呼びましょう．このとき，条件\\(P(x)\\)が真であるような\\(x \\in \\Omega\\)の集まりで\\(\\Omega\\)の部分集合\\(P\\)を構成できます．これを\\(P=\\{ x \\in \\Omega:P(x) \\}\\)と書きます． このように考えると，集合に関する演算と命題の結合を以下のように対応させることができます． いま，条件\\(P(x), Q(x)\\)で定まる集合\\(P= \\{ x \\in \\Omega:P(X) \\}\\)，\\(Q=\\{ x \\in \\Omega:Q(X) \\}\\)について， \\[ \\begin{aligned} P \\cap Q &amp;= \\{ x \\in \\Omega: P(x) \\land Q(x) \\} \\\\ P \\cup Q &amp;= \\{ x \\in \\Omega: P(x) \\lor Q(x) \\} \\\\ P^c &amp;= \\{ x \\in \\Omega: \\neg P(x) \\} \\end{aligned} \\] となります． 8.5.2 全称命題と存在命題 前項で言及した全称記号と存在記号を用いて全称命題と存在命題を次のように定義します． Definition 8.3 (全称命題と存在命題) 集合\\(\\Omega\\)上の条件\\(P(x)\\)に対して，「\\({}^\\forall x \\in \\Omega\\)について\\(P(x)\\)は真である」という主張を全称命題と呼びます．これを \\[ {}^\\forall x \\in \\Omega, P(X) \\] と書き．同じように「\\({}^\\exists x \\in \\Omega\\)について\\(P(x)\\)は真である」という主張を存在命題と呼び \\[ {}^\\exists x \\in \\Omega, P(x) \\] と書きます． また，\\(\\rm s.t.\\)を使って「\\({}^\\exists x \\in \\Omega \\ \\rm{s.t.} \\ P(x)\\)」のように表すこともあります． 8.5.3 存在記号と一意な存在 存在記号\\(\\exists\\)は，条件を満たすものが少なくとも１つは存在することを主張しているだけで，具体的にそれがどんなものであるか，またそれがいくつあるかは言及しません．一方で，命題によっては条件を満たすものが唯一存在することを主張する場合もあります．そのような場合は「存在が一意である」，「一意に存在する」，「唯一つに定まる」などと表現します．一意に存在することを記号で\\(\\exists 1\\)や\\(\\exists !\\)などと表すこともあります． 8.5.4 全称命題と存在命題の例 全称命題と存在命題の概念に慣れることは，数学の言葉を理解するのに大いに役立ちます．ここではいくつか例を紹介します． Example 8.5 (いくらでも大きい) 「条件\\(P(x)\\)を満たす，いくらでも大きな自然数\\(n\\)が存在する」 という形の主張があります．例えば，「いくらでも大きな素数がある」などが挙げられます．これを厳密に述べるために，次のように表現します． 「どんな自然数\\(N\\)に対しても，それより大きい\\(n\\)が存在して，条件\\(P(x)\\)を満たす．」 これを記号で書けば \\[ {}^\\forall N \\in \\mathbb N, {}^\\exists n \\in \\mathbb N, \\hspace{3mm} \\rm{s.t.} \\hspace{3mm} (n &gt; N) \\land P(n). \\] とできます． Example 8.6 (十分大きい) 「十分に大きい自然数\\(n\\)について条件\\(P(x)\\)が成り立つ」というタイプの主張があります．例えば「十分に大きい自然数\\(n\\)について，\\(100n &lt; n^2\\)が成り立つ」と言ったものです．これは，具体的にどこからかについては言及しないが，そこから先の自然数については常に成立していることを意味しています．この「十分に大きい」をもっと厳密に述べると 「ある自然数\\(N\\)に対して，それよりも大きいどんな\\(n\\)についても，条件\\(P(n)\\)を満たす」となります．これを記号で書くと \\[ {}^\\exists N \\in \\mathbb N, {}^\\forall n \\in \\mathbb N, \\hspace{3mm} \\rm{s.t.} \\hspace{3mm} (n &gt; N) \\land P(n). \\] となります． Example 8.7 (単位元の存在) 「自然数\\(e\\)が存在して，どんな自然数\\(n\\)に対しても積\\(en\\)の結果が\\(n\\)になる」ということを記号で書けば \\[ {}^\\exists e \\in \\mathbb N, {}^\\forall n \\in \\mathbb N, ne=n. \\] となります． Example 8.8 (逆元の存在) 「どんな自然数\\(n\\)に対しても，\\(n\\)との積の結果が\\(1\\)になるような数\\(p\\)（自然数とは限らない）」が存在する」これを記号で書けば \\[ {}^\\forall n \\in \\mathbb N, {}^\\exists p \\in \\Omega, np=1. \\] 実際，\\(n\\)に対して\\(p = 1/n\\)を取れば成り立ちます． "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
